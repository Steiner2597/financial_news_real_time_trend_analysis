# 单次清洗逻辑重构说明

## 🎯 问题描述

**原问题**: 清洗器使用 `cursor_loop()` 会一直循环运行，导致流程卡在数据清洗阶段，无法继续下一步。

## ✨ 解决方案

重构为**单次处理模式**：

```
收到通知 → 清洗当前队列中的数据 → 发送通知 → 继续待命
```

## 🔄 工作流程对比

### 原流程（阻塞）

```
爬虫完成 → 发送通知
              ↓
         清洗器收到通知
              ↓
         开始 cursor_loop() ← 一直循环，阻塞在这里
              ↓
         永远不会发送完成通知
              ↓
         Processor 永远等待
```

### 新流程（非阻塞）

```
爬虫完成 → 发送通知
              ↓
         清洗器收到通知
              ↓
         单次清洗当前队列数据 ✅
              ↓
         清洗完成 → 发送通知给 Processor
              ↓
         Processor 开始处理
              |
              ↓
         清洗器继续待命 ← 准备接收下一次通知
```

## 📦 新增组件

### SinglePassCleaner（单次清洗器）

位置: `cleaner/event_driven/single_pass_cleaner.py`

**核心方法**:

```python
def clean_once(batch_size=100):
    """执行一次清洗操作，只处理当前队列中的数据"""
    # 1. 获取队列当前长度
    # 2. 批量处理这些数据
    # 3. 处理完成后返回统计结果
    # ✅ 不会等待新数据，不会循环
```

**特点**:
- ✅ 只处理当前队列中的数据
- ✅ 处理完成后立即返回
- ✅ 不会阻塞主循环
- ✅ 支持批量处理（默认 100 条/批）
- ✅ 自动去重（支持 SET 和 ZSET）
- ✅ 数据验证和清洗
- ✅ 导出到文件

## 🔧 修改的文件

### 1. `cleaner/event_driven/cleaner.py`

**修改内容**:

```python
# 原来
def _run_cleaning(self):
    cursor_loop()  # ❌ 一直循环

# 现在
def _run_cleaning(self):
    cleaner = SinglePassCleaner(...)
    stats = cleaner.clean_once()  # ✅ 单次处理
    cleaner.close()
    return stats['cleaned']
```

**优势**:
- 收到通知 → 清洗 → 完成 → 继续待命
- 不会阻塞事件循环
- 每次清洗都是独立的

### 2. `cleaner/event_driven/__init__.py`

新增导出:
```python
from .single_pass_cleaner import SinglePassCleaner
```

## 🚀 使用方法

### 方式 1: 事件驱动模式（推荐）

```bash
cd cleaner
python data_cleaner_event_driven_v2.py
```

**工作流程**:
1. 启动后等待爬虫通知
2. 收到 `crawler_complete` 通知
3. 执行单次清洗
4. 发送 `cleaner_complete` 通知
5. 继续待命

### 方式 2: 手动测试单次清洗

```bash
cd cleaner
python test_single_pass_cleaning.py
```

### 方式 3: 持续轮询模式

```bash
python data_cleaner_event_driven_v2.py --mode continuous
```

每 5 秒检查一次队列，有数据就清洗。

## 📊 单次清洗流程

```
┌─────────────────────────────────────┐
│   1. 获取队列长度 (N 条数据)         │
└───────────────┬─────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│   2. 批量弹出数据 (100 条/批)        │
└───────────────┬─────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│   3. 对每条数据:                     │
│      - 验证数据                      │
│      - 检查去重                      │
│      - 清洗数据                      │
│      - 推送到输出队列                │
└───────────────┬─────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│   4. 处理完 N 条数据后返回           │
│      ✅ 不等待新数据                 │
│      ✅ 不进入循环                   │
└─────────────────────────────────────┘
```

## 🎯 核心改进

### 改进 1: 明确的处理边界

```python
# 原来: 不知道什么时候结束
while True:
    data = queue.get()  # 一直等待
    clean(data)

# 现在: 明确的处理边界
queue_length = get_queue_length()  # N 条
for i in range(queue_length):  # 只处理 N 条
    data = queue.pop()
    clean(data)
# 处理完成，返回
```

### 改进 2: 快速响应

```python
# 收到通知后
queue: [A, B, C, D, E]  # 5 条数据
        ↓
clean_once()  # 处理这 5 条
        ↓
返回统计: {cleaned: 5, ...}
        ↓
发送通知给 Processor
        ↓
继续待命  # 不阻塞
```

### 改进 3: 批量优化

```python
# 批量处理，减少 Redis 操作次数
batch_size = 100
while processed < total:
    batch = pop_batch(100)  # 一次弹出 100 条
    process_batch(batch)    # 批量处理
```

## 📈 性能对比

| 指标 | 原逻辑 (cursor_loop) | 新逻辑 (clean_once) |
|-----|---------------------|-------------------|
| **阻塞性** | ❌ 一直循环，阻塞 | ✅ 单次处理，不阻塞 |
| **完成时间** | ❌ 永远不结束 | ✅ 立即返回 |
| **通知发送** | ❌ 无法发送 | ✅ 及时发送 |
| **流程继续** | ❌ 卡住 | ✅ 顺畅 |
| **资源占用** | ❌ 持续占用 | ✅ 按需使用 |

## 🔍 详细示例

### 完整的事件流

```
时刻 T1: 爬虫启动
         ↓
时刻 T2: 爬虫完成，推送 1000 条数据到 Redis DB0
         ↓
时刻 T3: 爬虫发送 'crawler_complete' 通知
         ↓
时刻 T4: 清洗器收到通知
         ├─ 记录: "收到爬虫完成通知"
         └─ 调用: clean_once()
                  ↓
时刻 T5: 开始清洗
         ├─ 队列长度: 1000 条
         ├─ 批量处理: 100 条/批
         └─ 进度显示: 100/1000, 200/1000...
                  ↓
时刻 T6: 清洗完成
         ├─ 统计: 清洗 800, 去重 150, 无效 50
         ├─ 导出文件
         └─ 发送 'cleaner_complete' 通知
                  ↓
时刻 T7: Processor 收到通知，开始处理
         ↓
时刻 T8: 清洗器继续待命
         └─ 等待下一次 'crawler_complete' 通知

✅ 整个流程顺畅，不阻塞！
```

## 🧪 测试验证

运行测试脚本:

```bash
cd cleaner
python test_single_pass_cleaning.py
```

预期输出:
```
✓ SinglePassCleaner 创建成功
执行单次清洗...
清洗结果:
  - 总处理: N
  - 清洗成功: M
  - 去重过滤: X
  - 无效数据: Y
✓ 清洗器已关闭
✅ 单次清洗器测试通过！
```

## 🎉 总结

### 问题
- ❌ cursor_loop() 一直循环
- ❌ 清洗流程阻塞
- ❌ 无法发送完成通知
- ❌ Processor 无法继续

### 解决
- ✅ clean_once() 单次处理
- ✅ 清洗完成后立即返回
- ✅ 及时发送完成通知
- ✅ 流程顺畅继续

### 优势
- 🚀 快速响应
- 🎯 明确的处理边界
- 💪 资源按需使用
- 🔄 支持多轮处理
- 📊 详细的统计信息

现在可以愉快地使用事件驱动的清洗器了！🎊
